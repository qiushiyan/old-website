{
  "hash": "571601cc5de85abd34e4731cfe054466",
  "result": {
    "markdown": "---\ntitle: A Taste of dplyr 1.0.0\ndate: '2020-06-02'\ncategories: [R]\nbibliography: ref.bib\ndescription:\n    A quick summary of some exciting features coming in dplyr 1.0, e.g. `across()`, row-wise operations and context-dependent expressions\nimage: featured.png\n---\n\n\nThis post uses the penguins dataset [@10.1371/journal.pone.0090081] for most demonstration purposes, modified by [Allison Horst](https://github.com/allisonhorst/penguins) (as an alternative to iris).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\n\npackageVersion(\"dplyr\")\n#> [1] '1.0.9'\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- palmerpenguins::penguins\npenguins\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n#>    <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n#>  1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n#>  2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n#>  3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n#>  4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n#>  5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n#>  6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n#>  7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n#>  8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n#>  9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n#> 10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  ggplot(aes(bill_length_mm, bill_depth_mm, color = species, shape = species)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n\n## Working within columns\n\nThe new `across()` function supersedes functionalities of `_at`, `_if`, `_all` variants. The first argument, `.cols`, selects the columns you want to operate on. It uses tidy selection (like `select()`) so you can pick variables by position, name, and type. The second argument, `.fns`, is a function or list of functions to apply to each column. This can also be a purrr style formula\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped <- penguins %>% group_by(species)\n\npenguins_grouped %>%\n  summarize(across(starts_with(\"bill\"), mean, na.rm = TRUE),\n            n = n())\n#> # A tibble: 3 × 4\n#>   species   bill_length_mm bill_depth_mm     n\n#>   <fct>              <dbl>         <dbl> <int>\n#> 1 Adelie              38.8          18.3   152\n#> 2 Chinstrap           48.8          18.4    68\n#> 3 Gentoo              47.5          15.0   124\n```\n:::\n\n\n\nFor conditional selection (previous `_if` variants), predicate function should be wrapped in `where`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# double all numeric columns\npenguins %>%\n  mutate(across(where(is.numeric), ~ .x * 2))\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n#>    <fct>   <fct>              <dbl>         <dbl>      <dbl>   <dbl> <fct> <dbl>\n#>  1 Adelie  Torgersen           78.2          37.4        362    7500 male   4014\n#>  2 Adelie  Torgersen           79            34.8        372    7600 fema…  4014\n#>  3 Adelie  Torgersen           80.6          36          390    6500 fema…  4014\n#>  4 Adelie  Torgersen           NA            NA           NA      NA <NA>   4014\n#>  5 Adelie  Torgersen           73.4          38.6        386    6900 fema…  4014\n#>  6 Adelie  Torgersen           78.6          41.2        380    7300 male   4014\n#>  7 Adelie  Torgersen           77.8          35.6        362    7250 fema…  4014\n#>  8 Adelie  Torgersen           78.4          39.2        390    9350 male   4014\n#>  9 Adelie  Torgersen           68.2          36.2        386    6950 <NA>   4014\n#> 10 Adelie  Torgersen           84            40.4        380    8500 <NA>   4014\n#> # … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n\n# count unique values of all character columns\npenguins %>%\n  summarize(across(where(is.character), ~ length(unique(.x))))\n#> # A tibble: 1 × 0\n```\n:::\n\n\n\nApply multiple functions using list and use the `.names` argument to control column names.\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(across(matches(\"mm\"),\n                   list(min = ~ min(.x, na.rm = TRUE),\n                        max = ~ max(.x, na.rm = TRUE)),\n                   .names = \"{fn}_{col}\"))\n#> # A tibble: 3 × 7\n#>   species   min_bill_length_mm max_bill_length…¹ min_b…² max_b…³ min_f…⁴ max_f…⁵\n#>   <fct>                  <dbl>             <dbl>   <dbl>   <dbl>   <int>   <int>\n#> 1 Adelie                  32.1              46      15.5    21.5     172     210\n#> 2 Chinstrap               40.9              58      16.4    20.8     178     212\n#> 3 Gentoo                  40.9              59.6    13.1    17.3     203     231\n#> # … with abbreviated variable names ¹​max_bill_length_mm, ²​min_bill_depth_mm,\n#> #   ³​max_bill_depth_mm, ⁴​min_flipper_length_mm, ⁵​max_flipper_length_mm\n```\n:::\n\n\n\n\n\n\n## Working within rows\n\n\nRow-wise operations require a special type of grouping where each group consists of a single row. You create this with `rowwise()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  student_id = 1:4,\n  test1 = 10:13,\n  test2 = 20:23,\n  test3 = 30:33,\n  test4 = 40:43\n)\ndf %>% rowwise()\n#> # A tibble: 4 × 5\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4\n#>        <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40\n#> 2          2    11    21    31    41\n#> 3          3    12    22    32    42\n#> 4          4    13    23    33    43\n```\n:::\n\n\n`rowwise` doesn’t need any additional arguments unless you have variables that identify the rows,  like `student_id`  here. This can be helpful when you want to keep a row identifier.\n\nLike `group_by`, `rowwise` doesn’t really do anything itself; it just changes how the other verbs work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40  26.5\n#> 2          2    11    21    31    41  26.5\n#> 3          3    12    22    32    42  26.5\n#> 4          4    13    23    33    43  26.5\n\ndf %>% rowwise() %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40    25\n#> 2          2    11    21    31    41    26\n#> 3          3    12    22    32    42    27\n#> 4          4    13    23    33    43    28\n```\n:::\n\n\nIn its essence, `rowwise` vectorize / parallelize a function to acheive rowwisee computation. And in this case, the `mean()` function is vectorized. If there are alternative ways of computing row-wise summaries that take advantage of built-in vectorisation then we do not need `rowwise` at all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n\ndf %>% rowwise() %>% mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n```\n:::\n\n\nAnother family of summary functions have “parallel” extensions where you can provide multiple variables in the arguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(min = pmin(test1, test2, test3, test4),\n         max = pmax(test1, test2, test3, test4),\n         string = paste(test1, test2, test3, test4, sep = \"-\"))\n#> # A tibble: 4 × 8\n#>   student_id test1 test2 test3 test4   min   max string     \n#>        <int> <int> <int> <int> <int> <int> <int> <chr>      \n#> 1          1    10    20    30    40    10    40 10-20-30-40\n#> 2          2    11    21    31    41    11    41 11-21-31-41\n#> 3          3    12    22    32    42    12    42 12-22-32-42\n#> 4          4    13    23    33    43    13    43 13-23-33-43\n```\n:::\n\nWhere these functions exist, they’ll usually be faster than `rowwise`. The advantage of `rowwise` is that it works with any function, not just those that are already vectorised.\n\nHowever, an advantage of `rowwise` even there is other ways is that it’s paired with `c_across()`, which works like `c()` but uses the same tidyselect syntax as `across()`. That makes it easy to operate on multiple variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  mutate(min = min(c_across(starts_with(\"test\"))),\n         max = max(c_across(starts_with(\"test\"))))\n#> # A tibble: 4 × 7\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   min   max\n#>        <int> <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    10    40\n#> 2          2    11    21    31    41    11    41\n#> 3          3    12    22    32    42    12    42\n#> 4          4    13    23    33    43    13    43\n```\n:::\n\n\nPlus, a rowwise df will naturally contain exactly the same rows after `summarize()`, the same as `mutate`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  summarize(across(starts_with(\"test\"), ~ .x, .names = \"{col}_same\"))\n#> # A tibble: 4 × 4\n#>   test1_same test2_same test3_same test4_same\n#>        <int>      <int>      <int>      <int>\n#> 1         10         20         30         40\n#> 2         11         21         31         41\n#> 3         12         22         32         42\n#> 4         13         23         33         43\n```\n:::\n\n\n\n\n### List-columns\n\nBecause lists can contain anything, you can use list-columns to keep related objects together, regardless of what type of thing they are. List-columns give you a convenient storage mechanism and `rowwise` gives you a convenient computation mechanism.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = list(1, 2:3, 4:6),\n  y = list(TRUE, 1, \"a\"),\n  z = list(sum, mean, sd)\n)\ndf\n#> # A tibble: 3 × 3\n#>   x         y         z     \n#>   <list>    <list>    <list>\n#> 1 <dbl [1]> <lgl [1]> <fn>  \n#> 2 <int [2]> <dbl [1]> <fn>  \n#> 3 <int [3]> <chr [1]> <fn>\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  summarize(\n    x_length = length(x),\n    y_type = typeof(y),\n    z_call = z(1:5)\n  )\n#> # A tibble: 3 × 3\n#>   x_length y_type    z_call\n#>      <int> <chr>      <dbl>\n#> 1        1 logical    15   \n#> 2        2 double      3   \n#> 3        3 character   1.58\n```\n:::\n\n\n\n### Simulaiton\n\nThe basic idea of using `rowwise` to perform simulation is to store all your simulation paramters in a data frame, similar to `purrr::pmap`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~id, ~ n, ~ min, ~ max,\n    1,   3,     0,     1,\n    2,   2,    10,   100,\n    3,   2,   100,  1000,\n)\n```\n:::\n\n\nThen you can either generate a list-column containing the simulated values with `mutate`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  mutate(sim = list(runif(n, min, max)))\n#> # A tibble: 3 × 5\n#> # Rowwise: \n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n```\n:::\n\nOr taking advantage of `summarize`'s new features to return multiple rows per group\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise(everything()) %>%\n  summarize(sim = runif(n, min, max))\n#> # A tibble: 7 × 5\n#> # Groups:   id, n, min, max [3]\n#>      id     n   min   max     sim\n#>   <dbl> <dbl> <dbl> <dbl>   <dbl>\n#> 1     1     3     0     1   0.644\n#> 2     1     3     0     1   0.201\n#> 3     1     3     0     1   0.151\n#> 4     2     2    10   100  84.5  \n#> 5     2     2    10   100  80.2  \n#> 6     3     2   100  1000 311.   \n#> 7     3     2   100  1000 372.\n```\n:::\n\n\nThe previous approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(sim = purrr::pmap(., ~ runif(..2, ..3, ..4)))\n#> # A tibble: 3 × 5\n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n```\n:::\n\n\n\n\n## Group-wise models\n\nThe new `nest_by()` function works similarly to `group_nest()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species <- penguins %>% nest_by(species)\nby_species\n#> # A tibble: 3 × 2\n#> # Rowwise:  species\n#>   species                 data\n#>   <fct>     <list<tibble[,7]>>\n#> 1 Adelie             [152 × 7]\n#> 2 Chinstrap           [68 × 7]\n#> 3 Gentoo             [124 × 7]\n```\n:::\n\nNow we can use `mutate` to fit a model to each data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species <- by_species %>%\n  rowwise(species) %>%\n  mutate(model = list(lm(bill_length_mm ~ bill_depth_mm, data = data)))\n\nby_species\n#> # A tibble: 3 × 3\n#> # Rowwise:  species\n#>   species                 data model \n#>   <fct>     <list<tibble[,7]>> <list>\n#> 1 Adelie             [152 × 7] <lm>  \n#> 2 Chinstrap           [68 × 7] <lm>  \n#> 3 Gentoo             [124 × 7] <lm>\n```\n:::\n\nAnd then extract model summaries or coefficients with `summarize()` and `broom` functions (note that `by_species` is still a rowwise data frame):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species %>%\n  summarize(broom::glance(model))\n#> # A tibble: 3 × 13\n#> # Groups:   species [3]\n#>   species   r.squared adj.r.sq…¹ sigma stati…²  p.value    df logLik   AIC   BIC\n#>   <fct>         <dbl>      <dbl> <dbl>   <dbl>    <dbl> <dbl>  <dbl> <dbl> <dbl>\n#> 1 Adelie        0.153      0.148  2.46    27.0 6.67e- 7     1  -349.  704.  713.\n#> 2 Chinstrap     0.427      0.418  2.55    49.2 1.53e- 9     1  -159.  324.  331.\n#> 3 Gentoo        0.414      0.409  2.37    85.5 1.02e-15     1  -280.  565.  574.\n#> # … with 3 more variables: deviance <dbl>, df.residual <int>, nobs <int>, and\n#> #   abbreviated variable names ¹​adj.r.squared, ²​statistic\n#> # ℹ Use `colnames()` to see all variable names\n\nby_species %>%\n  summarize(broom::tidy(model))\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n```\n:::\n\n\nAn alternative approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  group_by(species) %>%\n  group_modify(~ broom::tidy(lm(bill_length_mm ~ bill_depth_mm, data = .x)))\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n```\n:::\n\n\n\n\n## New `summarize` features\n\n### Multiple rows and columns\n\nTwo big changes make `summarize()` much more flexible. A single summary expression can now return:\n\n- A vector of any length, creating multiple rows. (so we can use summary that returns multiple values without `list`)\n\n- A data frame, creating multiple columns.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(bill_length_dist = quantile(bill_length_mm,\n                                          c(0.25, 0.5, 0.75),\n                                          na.rm = TRUE),\n            q = c(0.25, 0.5, 0.75))\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   bill_length_dist     q\n#>   <fct>                <dbl> <dbl>\n#> 1 Adelie                36.8  0.25\n#> 2 Adelie                38.8  0.5 \n#> 3 Adelie                40.8  0.75\n#> 4 Chinstrap             46.3  0.25\n#> 5 Chinstrap             49.6  0.5 \n#> 6 Chinstrap             51.1  0.75\n#> 7 Gentoo                45.3  0.25\n#> 8 Gentoo                47.3  0.5 \n#> 9 Gentoo                49.6  0.75\n```\n:::\n\n\n\nOr return multiple columns from a single summary expression:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(tibble(min = min(bill_depth_mm, na.rm = TRUE),\n                   max = max(bill_depth_mm, na.rm = TRUE)))\n#> # A tibble: 3 × 3\n#>   species     min   max\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     15.5  21.5\n#> 2 Chinstrap  16.4  20.8\n#> 3 Gentoo     13.1  17.3\n```\n:::\n\n\n\nAt the first glance this may seem not so different with supplying multiple name-value pairs. But this can be useful inside functions. For example, in the previous `quantile` code it would be nice to be able to reduce the duplication so that we don’t have to type the quantile values twice. We can now write a simple function because summary expressions can now be data frames or tibbles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(x = quantile(x, q, na.rm = na.rm), q = q)\n}\n\npenguins_grouped %>%\n  summarize(quibble(bill_depth_mm))\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species       x     q\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     17.5  0.25\n#> 2 Adelie     18.4  0.5 \n#> 3 Adelie     19    0.75\n#> 4 Chinstrap  17.5  0.25\n#> 5 Chinstrap  18.4  0.5 \n#> 6 Chinstrap  19.4  0.75\n#> 7 Gentoo     14.2  0.25\n#> 8 Gentoo     15    0.5 \n#> 9 Gentoo     15.7  0.75\n```\n:::\n\n\nWhen combining glue syntax and tidy evaluation, it is easy to dynamically name the column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(\"{{ x }}_quantile\" := quantile(x, q, na.rm = na.rm),\n         \"{{ x }}_q\" := q)\n}\n\npenguins_grouped %>%\n  summarize(quibble(flipper_length_mm))\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   flipper_length_mm_quantile flipper_length_mm_q\n#>   <fct>                          <dbl>               <dbl>\n#> 1 Adelie                           186                0.25\n#> 2 Adelie                           190                0.5 \n#> 3 Adelie                           195                0.75\n#> 4 Chinstrap                        191                0.25\n#> 5 Chinstrap                        196                0.5 \n#> 6 Chinstrap                        201                0.75\n#> 7 Gentoo                           212                0.25\n#> 8 Gentoo                           216                0.5 \n#> 9 Gentoo                           221                0.75\n```\n:::\n\n\nAs an aside, if we name the tibble expression in `summarize()` that part will be packed in the result, which can be solved by `tidyr::unpack`. That’s because when we leave the name off, the data frame result is automatically unpacked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(df = quibble(flipper_length_mm))\n#> # A tibble: 9 × 2\n#> # Groups:   species [3]\n#>   species   df$flipper_length_mm_quantile $flipper_length_mm_q\n#>   <fct>                             <dbl>                <dbl>\n#> 1 Adelie                              186                 0.25\n#> 2 Adelie                              190                 0.5 \n#> 3 Adelie                              195                 0.75\n#> 4 Chinstrap                           191                 0.25\n#> 5 Chinstrap                           196                 0.5 \n#> 6 Chinstrap                           201                 0.75\n#> 7 Gentoo                              212                 0.25\n#> 8 Gentoo                              216                 0.5 \n#> 9 Gentoo                              221                 0.75\n```\n:::\n\n\n\n\n### non-summary context\n\nIn combination with rowwise operations,  `summarize()` is now sufficiently powerful to replace many workflows that previously required a `map()` function.\n\nFor example, to read all the all the .csv files in the current directory, you could write:\n\n```r\ntibble(path = dir(pattern = \"\\\\.csv$\")) %>%\n  rowwise(path) %>%\n  summarize(read_csv(path))\n```\n\n\n## Move columns around within data frames\n\nNew verb `relocate` is provided to change column positions with the same syntax as `select`. The default behavior is to move selected columns to the left-hand side\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% relocate(island)\n#> # A tibble: 344 × 8\n#>    island    species bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n#>    <fct>     <fct>            <dbl>         <dbl>      <int>   <int> <fct> <int>\n#>  1 Torgersen Adelie            39.1          18.7        181    3750 male   2007\n#>  2 Torgersen Adelie            39.5          17.4        186    3800 fema…  2007\n#>  3 Torgersen Adelie            40.3          18          195    3250 fema…  2007\n#>  4 Torgersen Adelie            NA            NA           NA      NA <NA>   2007\n#>  5 Torgersen Adelie            36.7          19.3        193    3450 fema…  2007\n#>  6 Torgersen Adelie            39.3          20.6        190    3650 male   2007\n#>  7 Torgersen Adelie            38.9          17.8        181    3625 fema…  2007\n#>  8 Torgersen Adelie            39.2          19.6        195    4675 male   2007\n#>  9 Torgersen Adelie            34.1          18.1        193    3475 <NA>   2007\n#> 10 Torgersen Adelie            42            20.2        190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n\npenguins %>% relocate(starts_with(\"bill\"))\n#> # A tibble: 344 × 8\n#>    bill_length_mm bill_depth_mm species island    flipper_…¹ body_…² sex    year\n#>             <dbl>         <dbl> <fct>   <fct>          <int>   <int> <fct> <int>\n#>  1           39.1          18.7 Adelie  Torgersen        181    3750 male   2007\n#>  2           39.5          17.4 Adelie  Torgersen        186    3800 fema…  2007\n#>  3           40.3          18   Adelie  Torgersen        195    3250 fema…  2007\n#>  4           NA            NA   Adelie  Torgersen         NA      NA <NA>   2007\n#>  5           36.7          19.3 Adelie  Torgersen        193    3450 fema…  2007\n#>  6           39.3          20.6 Adelie  Torgersen        190    3650 male   2007\n#>  7           38.9          17.8 Adelie  Torgersen        181    3625 fema…  2007\n#>  8           39.2          19.6 Adelie  Torgersen        195    4675 male   2007\n#>  9           34.1          18.1 Adelie  Torgersen        193    3475 <NA>   2007\n#> 10           42            20.2 Adelie  Torgersen        190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n\npenguins %>% relocate(sex, body_mass_g, .after = species)\n#> # A tibble: 344 × 8\n#>    species sex    body_mass_g island    bill_length_mm bill_dept…¹ flipp…²  year\n#>    <fct>   <fct>        <int> <fct>              <dbl>       <dbl>   <int> <int>\n#>  1 Adelie  male          3750 Torgersen           39.1        18.7     181  2007\n#>  2 Adelie  female        3800 Torgersen           39.5        17.4     186  2007\n#>  3 Adelie  female        3250 Torgersen           40.3        18       195  2007\n#>  4 Adelie  <NA>            NA Torgersen           NA          NA        NA  2007\n#>  5 Adelie  female        3450 Torgersen           36.7        19.3     193  2007\n#>  6 Adelie  male          3650 Torgersen           39.3        20.6     190  2007\n#>  7 Adelie  female        3625 Torgersen           38.9        17.8     181  2007\n#>  8 Adelie  male          4675 Torgersen           39.2        19.6     195  2007\n#>  9 Adelie  <NA>          3475 Torgersen           34.1        18.1     193  2007\n#> 10 Adelie  <NA>          4250 Torgersen           42          20.2     190  2007\n#> # … with 334 more rows, and abbreviated variable names ¹​bill_depth_mm,\n#> #   ²​flipper_length_mm\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n\nSimilarly, `mutate` gains new arguments `.after` and `.before` to control where new columns should appear.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  mutate(mass_double = body_mass_g * 2, .before = 1)\n#> # A tibble: 344 × 9\n#>    mass_double species island    bill_leng…¹ bill_…² flipp…³ body_…⁴ sex    year\n#>          <dbl> <fct>   <fct>           <dbl>   <dbl>   <int>   <int> <fct> <int>\n#>  1        7500 Adelie  Torgersen        39.1    18.7     181    3750 male   2007\n#>  2        7600 Adelie  Torgersen        39.5    17.4     186    3800 fema…  2007\n#>  3        6500 Adelie  Torgersen        40.3    18       195    3250 fema…  2007\n#>  4          NA Adelie  Torgersen        NA      NA        NA      NA <NA>   2007\n#>  5        6900 Adelie  Torgersen        36.7    19.3     193    3450 fema…  2007\n#>  6        7300 Adelie  Torgersen        39.3    20.6     190    3650 male   2007\n#>  7        7250 Adelie  Torgersen        38.9    17.8     181    3625 fema…  2007\n#>  8        9350 Adelie  Torgersen        39.2    19.6     195    4675 male   2007\n#>  9        6950 Adelie  Torgersen        34.1    18.1     193    3475 <NA>   2007\n#> 10        8500 Adelie  Torgersen        42      20.2     190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​bill_length_mm,\n#> #   ²​bill_depth_mm, ³​flipper_length_mm, ⁴​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n## Row mutation\n\ndplyr has a new experimental family of row mutation functions inspired by SQL’s `UPDATE`, `INSERT`, `UPSERT`, and `DELETE`. Like the join functions, they all work with a pair of data frames:\n\n\n- `rows_update(x, y)` updates existing rows in x with values in y.\n\n- `rows_patch(x, y)` works like rows_update() but only changes `NA` values.\n\n- `rows_insert(x, y)` adds new rows to x from y.\n\n- `rows_upsert(x, y)` updates existing rows in x and adds new rows from y.\n\n- `rows_delete(x, y)` deletes rows in x that match rows in y.\n\n\nThe `rows_` functions match x and y using **keys**.  All of them check that the keys of x and y are valid (i.e. unique) before doing anything.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndf\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n```\n:::\n\n\nWe can use `rows_insert()` to add new rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew <- tibble(a = c(4, 5), b = c(\"d\", \"e\"), c = c(3.5, 4.5))\n\nrows_insert(df, new)\n#> # A tibble: 5 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     4 d       3.5\n#> 5     5 e       4.5\n```\n:::\n\nNote that `rows_insert()` will fail if we attempt to insert a row that already exists:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_insert(tibble(a = 3, b = \"c\"))\n#> Error in `rows_insert()`:\n#> ! `y` can't contain keys that already exist in `x`.\n#> ℹ The following rows in `y` have keys that already exist in `x`: `c(1)`.\n#> ℹ Use `conflict = \"ignore\"` if you want to ignore these `y` rows.\n\ndf %>% rows_insert(tibble(a = 3, b = \"c\"), by = c(\"a\", \"b\"))\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     3 c      NA\n```\n:::\n\n\nIf you want to update existing values, use `rows_update()`. It will throw an error if one of the rows to update does not exist:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_update(tibble(a = 3, b = \"c\"))\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n\ndf %>% rows_update(tibble(a = 4, b = \"d\"))\n#> Error in `rows_update()`:\n#> ! `y` must contain keys that already exist in `x`.\n#> ℹ The following rows in `y` have keys that don't exist in `x`: `c(1)`.\n#> ℹ Use `unmatched = \"ignore\"` if you want to ignore these `y` rows.\n```\n:::\n\n`rows_patch()` is a variant of `rows_update()` that will only update values in x that are `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_patch(tibble(a = 1:3, b = \"patch\"))\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 patch   2.5\n```\n:::\n\n\n`row_upsert` update a df or insert new rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rows_upsert(tibble(a = 3, b = \"c\")) %>%  # update\n  rows_upsert(tibble(a = 4, b = \"d\")) # insert\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n#> 4     4 d      NA\n```\n:::\n\n\n\n\n## Context dependent expressions\n\n`n()` is a special function in dplyr which return the number of observations in the current group. Now the new version comes with more such special functions, aka context dependent expressions. These functions return information about the \"current\" group or \"current\" variable, so only work inside specific contexts like `summarize()` and `mutate()`. Specifically, a family of `cur_` functions are added:\n\n- `cur_data()` gives the current data for the current group (exclusing grouping variables, `cur_data_all` in developmental version returns grouping variables as well)\n\n- `cur_group()` gives the group keys, a tibble with one row and one column for each grouping variable.\n\n- `cur_group_id()` gives a unique numeric identifier for the current group\n\n- `cur_column()` gives the **name** of the current column (in `across()` only).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  g = sample(rep(letters[1:3], 1:3)),\n  x = runif(6),\n  y = runif(6)\n)\ngf <- df %>% group_by(g)\n\ngf %>% summarize(row = cur_group_rows())\n#> # A tibble: 6 × 2\n#> # Groups:   g [3]\n#>   g       row\n#>   <chr> <int>\n#> 1 a         3\n#> 2 b         1\n#> 3 b         2\n#> 4 c         4\n#> 5 c         5\n#> 6 c         6\ngf %>% summarize(data = list(cur_group()))\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 1]>\n#> 2 b     <tibble [1 × 1]>\n#> 3 c     <tibble [1 × 1]>\ngf %>% summarize(data = list(cur_data()))\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 2]>\n#> 2 b     <tibble [2 × 2]>\n#> 3 c     <tibble [3 × 2]>\n# has nothing to do with groups\ngf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))\n#> # A tibble: 6 × 3\n#> # Groups:   g [3]\n#>   g     x      y     \n#>   <chr> <chr>  <chr> \n#> 1 b     x 0.02 y 0.17\n#> 2 b     x 0.65 y 0.53\n#> 3 a     x 0.84 y 0.49\n#> 4 c     x 0.32 y 0.62\n#> 5 c     x 0.35 y 0.6 \n#> 6 c     x 0.57 y 0.08\n```\n:::\n\n\n\n\n\n\n## Superseded functions\n\n`top_n()`, `sample_n()`, and `sample_frac()` have been superseded in favor of a new family of slice helpers: `slice_min()`, `slice_max()`, `slice_head()`, `slice_tail()`, `slice_random()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select penguins per group on body mass\npenguins_grouped %>%\n  slice_max(body_mass_g, n = 1)\n#> # A tibble: 3 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_le…¹ body_…² sex    year\n#>   <fct>     <fct>           <dbl>         <dbl>        <int>   <int> <fct> <int>\n#> 1 Adelie    Biscoe           43.2          19            197    4775 male   2009\n#> 2 Chinstrap Dream            52            20.7          210    4800 male   2008\n#> 3 Gentoo    Biscoe           49.2          15.2          221    6300 male   2007\n#> # … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\npenguins_grouped %>%\n  slice_min(body_mass_g, n = 1)\n#> # A tibble: 4 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_le…¹ body_…² sex    year\n#>   <fct>     <fct>           <dbl>         <dbl>        <int>   <int> <fct> <int>\n#> 1 Adelie    Biscoe           36.5          16.6          181    2850 fema…  2008\n#> 2 Adelie    Biscoe           36.4          17.1          184    2850 fema…  2008\n#> 3 Chinstrap Dream            46.9          16.6          192    2700 fema…  2008\n#> 4 Gentoo    Biscoe           42.7          13.7          208    3950 fema…  2008\n#> # … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# random sampling\npenguins %>%\n  slice_sample(n = 10)\n#> # A tibble: 10 × 8\n#>    species   island    bill_length_mm bill_depth_mm flippe…¹ body_…² sex    year\n#>    <fct>     <fct>              <dbl>         <dbl>    <int>   <int> <fct> <int>\n#>  1 Chinstrap Dream               48.1          16.4      199    3325 fema…  2009\n#>  2 Gentoo    Biscoe              42            13.5      210    4150 fema…  2007\n#>  3 Gentoo    Biscoe              54.3          15.7      231    5650 male   2008\n#>  4 Gentoo    Biscoe              45.2          14.8      212    5200 fema…  2009\n#>  5 Adelie    Torgersen           41.5          18.3      195    4300 male   2009\n#>  6 Gentoo    Biscoe              49.9          16.1      213    5400 male   2009\n#>  7 Chinstrap Dream               50.5          19.6      201    4050 male   2007\n#>  8 Adelie    Biscoe              35.3          18.9      187    3800 fema…  2007\n#>  9 Adelie    Biscoe              37.8          20        190    4250 male   2009\n#> 10 Adelie    Torgersen           42            20.2      190    4250 <NA>   2007\n#> # … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\npenguins %>%\n  slice_sample(prop = 0.1)\n#> # A tibble: 34 × 8\n#>    species   island bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n#>    <fct>     <fct>           <dbl>         <dbl>       <int>   <int> <fct> <int>\n#>  1 Adelie    Dream            44.1          19.7         196    4400 male   2007\n#>  2 Gentoo    Biscoe           48.6          16           230    5800 male   2008\n#>  3 Gentoo    Biscoe           49.1          15           228    5500 male   2009\n#>  4 Chinstrap Dream            46.2          17.5         187    3650 fema…  2008\n#>  5 Gentoo    Biscoe           52.2          17.1         228    5400 male   2009\n#>  6 Gentoo    Biscoe           48.4          14.4         203    4625 fema…  2009\n#>  7 Adelie    Biscoe           38.8          17.2         180    3800 male   2007\n#>  8 Gentoo    Biscoe           44.5          14.3         216    4100 <NA>   2007\n#>  9 Chinstrap Dream            51.9          19.5         206    3950 male   2009\n#> 10 Gentoo    Biscoe           43.5          15.2         213    4650 fema…  2009\n#> # … with 24 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n`summarize()` gains new argument `.groups` to control grouping structure of theh result.\n\n\n- `.groups = \"drop_last\"` drops the last grouping level (i.e. the default behaviour).\n\n- `.groups = \"drop\"` drops all grouping levels and returns a tibble.\n\n- `.groups = \"keep\"` preserves the grouping of the input.\n\n- `.groups = \"rowwise\"` turns each row into its own group.\n\n\n## Other changes\n\nThe new `rename_with()` makes it easier to rename variables programmatically:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  rename_with(stringr::str_to_upper)\n#> # A tibble: 344 × 8\n#>    SPECIES ISLAND    BILL_LENGTH_MM BILL_DEPTH_MM FLIPPER_…¹ BODY_…² SEX    YEAR\n#>    <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n#>  1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n#>  2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n#>  3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n#>  4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n#>  5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n#>  6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n#>  7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n#>  8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n#>  9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n#> 10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​FLIPPER_LENGTH_MM,\n#> #   ²​BODY_MASS_G\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\nYou can optionally choose which columns to apply the transformation to with the second argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  rename_with(stringr::str_to_upper, starts_with(\"bill\"))\n#> # A tibble: 344 × 8\n#>    species island    BILL_LENGTH_MM BILL_DEPTH_MM flipper_…¹ body_…² sex    year\n#>    <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n#>  1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n#>  2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n#>  3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n#>  4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n#>  5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n#>  6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n#>  7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n#>  8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n#>  9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n#> 10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n#> # … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#> #   ²​body_mass_g\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n`mutate()` gains argument `.keep` that allows you to control which columns are retained in the output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% mutate(double_mass = body_mass_g * 2,\n                    island_lower = stringr::str_to_lower(island),\n                    .keep = \"used\")\n#> # A tibble: 344 × 4\n#>    island    body_mass_g double_mass island_lower\n#>    <fct>           <int>       <dbl> <chr>       \n#>  1 Torgersen        3750        7500 torgersen   \n#>  2 Torgersen        3800        7600 torgersen   \n#>  3 Torgersen        3250        6500 torgersen   \n#>  4 Torgersen          NA          NA torgersen   \n#>  5 Torgersen        3450        6900 torgersen   \n#>  6 Torgersen        3650        7300 torgersen   \n#>  7 Torgersen        3625        7250 torgersen   \n#>  8 Torgersen        4675        9350 torgersen   \n#>  9 Torgersen        3475        6950 torgersen   \n#> 10 Torgersen        4250        8500 torgersen   \n#> # … with 334 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\n\npenguins %>% mutate(double_mass = body_mass_g * 2, .keep = \"none\")\n#> # A tibble: 344 × 1\n#>    double_mass\n#>          <dbl>\n#>  1        7500\n#>  2        7600\n#>  3        6500\n#>  4          NA\n#>  5        6900\n#>  6        7300\n#>  7        7250\n#>  8        9350\n#>  9        6950\n#> 10        8500\n#> # … with 334 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n\n\n\n\n## Use cases\n\nThis in-progress section documents tasks that would otherwise been impossible or laborious with previous version of dplyr.\n\n### Replace missing values in many columns\n\nSince `tidyr::replace_na` does not support tidy select syntax, replacing NA values in multiple columns could be a drudgery. Now this is made easy with `coalesce` and `across`\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% summarize(across(starts_with(\"bill\"), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              2             2\n\npenguins %>%\n  mutate(across(starts_with(\"bill\"), ~ coalesce(.x, 0))) %>%\n  summarize(across(starts_with(\"bill\"), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              0             0\n```\n:::\n\n\n### Rolling regression\n\n`cur_data()` is particularly useful for rolling regression, in conjunction with the [slider](https://davisvaughan.github.io/slider/) package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(slider)\nlibrary(lubridate)\n# historical stock prices from 2014-2018 for Google, Amazon, Facebook and Apple\nstock <- tsibbledata::gafa_stock %>% select(Symbol, Date, Close, Volume)\nstock\n#> # A tibble: 5,032 × 4\n#>    Symbol Date       Close    Volume\n#>    <chr>  <date>     <dbl>     <dbl>\n#>  1 AAPL   2014-01-02  79.0  58671200\n#>  2 AAPL   2014-01-03  77.3  98116900\n#>  3 AAPL   2014-01-06  77.7 103152700\n#>  4 AAPL   2014-01-07  77.1  79302300\n#>  5 AAPL   2014-01-08  77.6  64632400\n#>  6 AAPL   2014-01-09  76.6  69787200\n#>  7 AAPL   2014-01-10  76.1  76244000\n#>  8 AAPL   2014-01-13  76.5  94623200\n#>  9 AAPL   2014-01-14  78.1  83140400\n#> 10 AAPL   2014-01-15  79.6  97909700\n#> # … with 5,022 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arrange and group by `Symbol` (i.e. Google)\nstock <- stock %>%\n  arrange(Symbol, Date) %>%\n  group_by(Symbol)\n\nlinear_model <- function(df) {\n  lm(Close ~ Volume, data = df)\n}\n\n# 10 day rolling regression per group\nstock %>%\n  mutate(model = slide_index(\n    cur_data(),\n    Date,\n    linear_model,\n    .before = days(9),\n    .complete = TRUE\n  ))\n#> # A tibble: 5,032 × 5\n#> # Groups:   Symbol [4]\n#>    Symbol Date       Close    Volume model \n#>    <chr>  <date>     <dbl>     <dbl> <list>\n#>  1 AAPL   2014-01-02  79.0  58671200 <NULL>\n#>  2 AAPL   2014-01-03  77.3  98116900 <NULL>\n#>  3 AAPL   2014-01-06  77.7 103152700 <NULL>\n#>  4 AAPL   2014-01-07  77.1  79302300 <NULL>\n#>  5 AAPL   2014-01-08  77.6  64632400 <NULL>\n#>  6 AAPL   2014-01-09  76.6  69787200 <NULL>\n#>  7 AAPL   2014-01-10  76.1  76244000 <NULL>\n#>  8 AAPL   2014-01-13  76.5  94623200 <lm>  \n#>  9 AAPL   2014-01-14  78.1  83140400 <lm>  \n#> 10 AAPL   2014-01-15  79.6  97909700 <lm>  \n#> # … with 5,022 more rows\n#> # ℹ Use `print(n = ...)` to see more rows\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}