{
  "hash": "60423a57bacb2688c67e9f6082175adc",
  "result": {
    "markdown": "---\ntitle: Generating dynamic contents in R Markdown and Quarto\ndate: '2023-01-22'\ncategories: [R]\ndescription:\n    A programmatic way of inserting dynamic contents into R Markdown and Quarto.\nimage: featured.jpg\n---\n\n\n\n\nA common scenario in my day-to-day data analysis is that I have many objects that are typically data frames, and for each of them I want to create a new section in my Quarto/R Markdown document with their respective summary statistics. The set of operations to apply are usually the same, just the data is different. A manual way of doing this would be copy-pasting the same chunk of code for generating the summaries, and only change the variable name. For instance:\n\n\n\n\n\n````default\n\n## Section for Data A\n\nData A has `r nrow(data_a)` rows and `r ncol(data_a)` columns.\n\n```{r}\nsummary_fn(data_a)\n```\n\n\n## Section for Data B\n\nData B has `r nrow(data_b)` rows and `r ncol(data_b)` columns.\n\n```{r}\nsummary_fn(data_b)\n```\n\n\n## Section for Data C\n\n...\n````\n\nThis becomes a pain when they are just so many objects and I have to change the name one by one. This post introduces a programmatic way of automating this task using `knit_child` from the `knitr` rendering engine.\n\n\n## Using the `knitr` engine\n\nThe `knitr` engine has built-in supports for dyanmic, parameterized documents. For R Markdown, you can pass data to the document using the `params` argument in `rmarkdown::render()`, learn more at <https://bookdown.org/yihui/rmarkdown/parameterized-reports.html>. This is intented for rendering one big parameterized `.Rmd` document.\n\nWhen it comes to inserting subcontents into either `.qmd` or `.Rmd` files, `knitr:::knit_child` is the function you need. Similar to `params` in `rmarkdown::render`, you can pass a environment object to `knitr:::knit_child` using the `envir` argument. The returned value of `knit_child` is simply the character string that can be directly embedded into a documnet, it's also used in conjunction with the chunk option `output = 'asis'` (Quarto) or `results = 'asis'` (R Markdown),\n\n`knit_child` accepts both an inline string `text` or a file path `file`. Below we use the inline string to generate a summary of the `iris` data frame.\n\n\n````{.cell-code}\n```{{r}}\n# chunk option output = 'asis'\nres <- knitr::knit_child(text = c(\n    '```{r}',\n    'summary(data)',\n    '```'\n  ), envir = rlang::env(data = iris), quiet = TRUE)\ncat(res, sep = \"\\n\")\n```\n````\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   Sepal.Length   Sepal.Width    Petal.Length   Petal.Width        Species  \n#>  Min.   :4.30   Min.   :2.00   Min.   :1.00   Min.   :0.1   setosa    :50  \n#>  1st Qu.:5.10   1st Qu.:2.80   1st Qu.:1.60   1st Qu.:0.3   versicolor:50  \n#>  Median :5.80   Median :3.00   Median :4.35   Median :1.3   virginica :50  \n#>  Mean   :5.84   Mean   :3.06   Mean   :3.76   Mean   :1.2                  \n#>  3rd Qu.:6.40   3rd Qu.:3.30   3rd Qu.:5.10   3rd Qu.:1.8                  \n#>  Max.   :7.90   Max.   :4.40   Max.   :6.90   Max.   :2.5\n```\n:::\n:::\n\n\nAll these combined, we could divide the job into a main document `main.Rmd` and a template document `_template.Rmd`. In the main document, we collect all the data, loop through them and insert them into the template document using `knitr:::knit_child`. Then we can use the `asis` output option to include the template document into the main document.\n\n::: {.column-margin}\n\nThis will also work for Quarto documents as long as we are using the knitr engine.\n\n:::\n\nThe example main and template documents are shown below:\n\n\n:::: {.columns}\n\n::: {.column width='45%' style=\"margin-right: 20px;\"}\n\nIn `main.Rmd`\n\n::: {.cell filename='main.Rmd'}\n::: {.cell-output .cell-output-stdout}\n````\n---\ntitle: \"Dynamic contents in R Markdown and Quarto with `knit_child()`\"\ntoc: true\n---\n\nGenerate random dataset\n\n```{r}\n#| echo: false\nrandom_data <- function(n) {\n  data.frame(\n    x = rnorm(n),\n    y = rnorm(n)\n  )\n}\n```\n\n```{r}\nall_data <- purrr::map(1:5, ~ random_data(round(runif(1, 10, 100))))\n```\n\n```{r}\nrender_child <- function(data, i) {\n  res = knitr::knit_child(\n   text = xfun::read_utf8(\"_template.Rmd\"),\n   envir = rlang::env(data = data, i = i),\n   quiet = TRUE\n  )\n  cat(res, sep = '\\n')\n  cat(\"\\n\")\n}\n```\n\nHere is a list of reports\n\n```{r}\n#| results: \"asis\"\n#| echo: false\npurrr::iwalk(all_data, render_child)\n```\n````\n:::\n:::\n\n:::\n\n::: {.column width='45%'}\n\nIn `_template.Rmd`\n\n::: {.cell filename='_template.Rmd'}\n::: {.cell-output .cell-output-stdout}\n````\n## Dataset `r i`\n\nDataset `r i` has `r nrow(data)` rows.\n\n### Summary\n\n```{r}\n#| echo: false\nsummary(data)\n```\n\n### Plot\n\n```{r}\n#| echo: false\n#| fig-align: center\nplot(data)\n```\n````\n:::\n:::\n\n:::\n\n::::\n\nI've defined a wrapper function `render_child()` that uses `knit_child()` under the hood. The key is you can pass arbitrary values using the `envir` argument. Whatever you need in the template document, you can pass them in as a named list and convert them into an environment object using `rlang::env()`.\n\nWhen you run the main document, it will generate a list of random data frames, generate a child document for each using the template document, and inserts the result back to the main document. The result is shown below:\n\n::: {.column-body-outset style=\"border: 3px solid #627891; padding: 20px; height: 900px\"}\n\n<iframe src = \"https://bookdown.org/qiushi/dynamic_contents_in_r_markdown_with_knit_child/\" frameBorder=\"0\" style=\"width:100%;height:100%\"> </iframe>\n\n:::\n\n\n\n## A note on `knitr::knit_expand`\n\n\n\n\n[R Markdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/knit-expand.html) also introduces a function called `knitr::knit_expand()` that can be used to insert contents into a template content. An example is shown below:\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::knit_expand(\n  text = \"The value of `a` is {{a}}\",\n  a = 1\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"The value of `a` is 1\"\n```\n:::\n:::\n\nSince you can also pass in a `file` argument in `knit_expand`, I was tempted to use this function with `knit_child` when I started to write this post. For example\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- knnitr::knit_expand(\n  file = \"template.Rmd\"\n  data = iris[1:5, ]\n)\n```\n:::\n\nThen you can access `iris` in the template document like so\n\n\n````default\n---\ntitle: template document\n---\n\n```{r}\n{{ data }}\n```\n````\n\nBut this will not work. `knitr::knit_expand` simply finds all the placeholders marked by `{{ }}`, interpolates them and then pass the text to the knitting functions.  This mechanism works fine you only need to insert simple primitives, such as strings and numbers, but not if you want to pass data.frames or other complex objects in general. Then the knitting functions will see a code chunk like this\n\n\n\n````default\n```{r}\nc(5.1, 4.9, 4.7, 4.6, 5)\nc(3.5, 3, 3.2, 3.1, 3.6)\nc(1.4, 1.4, 1.3, 1.5, 1.4)\nc(0.2, 0.2, 0.2, 0.2, 0.2)\nc(1, 1, 1, 1, 1)\n```\n\n````\n\nwhich is not valid R syntax.\n\n## Without `knitr`\n\nIt you are using Quarto with a different engine than `knitr`, I found no similar construct as `knitr::knit_child`. Although Quarto offers a native [variables](https://quarto.org/docs/authoring/variables.html) mechanism for reading values from configuration files, it's more suitable for static data shared across many documents. It also suffers the same problem as `knitr::knit_expand` that you are limited to whatever data structure that is supported by YAML.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}